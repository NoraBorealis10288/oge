@page "/uniqueaccesses"
@rendermode InteractiveServer

<PageTitle>Info Page</PageTitle>

<p class="title"><b>Unique Door Accesses</b></p>
<hr>

<div class="content">
    @if (Shared.uploadStatus.Equals("file")) {
        Init();
        <h4>Top 10 Days With Most Accesses by Unique Users</h4>
        @for (int i=0; i<10; i++) {
            <p>Door @data[i][0].GetID() was accessed @data[i].Count time(s) on the date @DateTime.Parse(data[i][0].GetTimestamp()).Date.ToString().Substring(0,DateTime.Parse(data[i][0].GetTimestamp()).Date.ToString().IndexOf(" 12:"))</p>
        }
    }
</div>

<style>

hr {
    border-top: 5px solid #000;
    opacity: 1;
    width: 80%;
    margin: auto;
}

.title {
    font-size: 70px;
    font-family: 'Courier New', monospace;
}

.content {
    text-align: center;
}

</style>

@code {
    Dictionary<(int door, DateTime day),List<ReaderEvent>> localDict;
    List<List<ReaderEvent>> data = new();
    String temp = "";
    public void Init() {
        localDict = ProcessDictionary(Shared.dict);
        foreach (KeyValuePair<(int,DateTime),List<ReaderEvent>> kvp in localDict) {
            data.Add(kvp.Value);
        }
        data.Sort( (x,y) => y.Count.CompareTo(x.Count) );
        foreach (List<ReaderEvent> list in data) {
            Console.WriteLine("Door {0} was accessed {1} time(s) on the date {2}", list[0].GetID(), list.Count, DateTime.Parse(list[0].GetTimestamp()).Date);
        }
    }

    public Dictionary<(int door, DateTime day),List<ReaderEvent>> ProcessDictionary(Dictionary<int, List<ReaderEvent>> dict) {
        Dictionary<(int door, DateTime day),List<ReaderEvent>> tempDict = new();
        List<ReaderEvent> tempList = new();

        // loop through all doors in master dictionary, finding each unique combination of doorID and day
        // and adding it as a key in the slave dictionary, with a list of the relevant readerevents as the value
        foreach (KeyValuePair<int, List<ReaderEvent>> kvp in dict) {
            foreach (ReaderEvent reader in kvp.Value) {
                Console.WriteLine("DEBUG STATEMENT ID: " + kvp.Key);
                Console.WriteLine("DEBUG STATEMENT DATETIME: " + reader.GetTimestamp() + ", " + DateTime.Parse(reader.GetTimestamp()) + ", " + DateTime.Parse(reader.GetTimestamp()).Date);
                if (!tempDict.ContainsKey((kvp.Key, DateTime.Parse(reader.GetTimestamp()).Date))) {
                    tempDict.Add( (kvp.Key, DateTime.Parse(reader.GetTimestamp()).Date), new List<ReaderEvent>() );
                }
                tempDict[ ( kvp.Key, DateTime.Parse(reader.GetTimestamp()).Date) ].Add(reader);
            }
        }

        // loop through all unique keys in slave dictionary, overwriting the value with
        // the results of calling ProcessList on that value dictionary values are read-only,
        // so I'm using this weird workaround to achieve the same thing
        foreach (KeyValuePair<(int,DateTime),List<ReaderEvent>> kvp in tempDict) {
            tempList = ProcessList(kvp.Value);
            kvp.Value.Clear();
            foreach (ReaderEvent reader in tempList) { kvp.Value.Add(reader); }
        }
        return tempDict;
    }

    public List<ReaderEvent> ProcessList(List<ReaderEvent> list) {
        // Sort list by id hash
        list.Sort( (x,y) => String.Compare(x.GetHash(),y.GetHash()) );

        // Remove duplicate hashes
        var tempList = new List<ReaderEvent>();
        tempList.Add(list[0]);
        if (list.Count >= 2) {
            for (int i=1; i<list.Count; i++) {
                if (!list[i-1].GetHash().Equals(list[i].GetHash())) {
                    tempList.Add(list[i]);
                }
            }
        }
        return tempList;
    }
}