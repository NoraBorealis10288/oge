@page "/inactivity"
@rendermode InteractiveServer

<PageTitle>Info Page</PageTitle>

<p class="title"><b>Longest Inactivity</b></p>
<hr>

<div class="content">
    @if (Shared.uploadStatus.Equals("file")) {
        Init();

        <h4>Top 10 Longest Gaps</h4>

        <table>
            <thead>
                <th>Door</th>
                <th>Start Date</th>
                <th>End Date</th>
                <th>Time (DD.HH:MM:SS)</th>
            </thead>
            <tbody>
                @for (int i=0; i<10; i++) {
                    <tr>
                        <td>@Shared.dict[data[i].doorID][0].GetDesc().Substring(22)</td>
                        <td>@data[i].start</td>
                        <td>@data[i].end</td>
                        <td>@data[i].gap</td>
                    </tr>
                }
            </tbody>
        </table>
    }
</div>

<style>

hr {
    border-top: 5px solid #000;
    opacity: 1;
    width: 80%;
    margin: auto;
}

.title {
    font-size: 70px;
    font-family: 'Courier New', monospace;
}

.content {
    text-align: center;
}

table, th, td {
  border: 1px solid black;
}

table {
    width: 50%;
    margin: auto;
}

th {
    background-color: #6b6c70;
    color: #ffffff;
}

</style>

@code {
    Dictionary<int,List<DateTime>> times = new Dictionary<int, List<DateTime>>();
    List<LongestGap> data;
    // Initialize local dictionary with just the timestamp of each access, grouped by which door they were from
    public void Init() {
        var templist = new List<string>();
        foreach (KeyValuePair<int,List<ReaderEvent>> kvp in Shared.dict) {
            templist.Clear();
            foreach (ReaderEvent reader in kvp.Value) {
                templist.Add(reader.GetTimestamp());
            }
            times.Add(kvp.Key,SortTimes(templist));
        }
        data = FindLongestInactivity(times);
    }

    public List<DateTime> SortTimes(List<string> input) {
        var output = new List<DateTime>();
        foreach (string timestamp in input) {
            output.Add(DateTime.Parse(timestamp));
        }
        output.Sort((x, y) => DateTime.Compare(x, y));

        return output;
    }

    public List<LongestGap> FindLongestInactivity(Dictionary<int, List<DateTime>> dict) {
        var list = new List<LongestGap>();
        DateTime start;
        DateTime end;
        TimeSpan gap;
        TimeSpan tempGap;
        
        foreach (KeyValuePair<int, List<DateTime>> kvp in dict) {
            if (kvp.Value.Count >= 2) {
                start = kvp.Value[0];
                end = kvp.Value[1];
                gap = end-start;
                List<DateTime> dates = kvp.Value;
                for (int i=1; i<dates.Count-1; i++) {
                    tempGap = dates[i+1]-dates[i];
                    if (tempGap > gap) {
                        gap = tempGap;
                        start = dates[i];
                        end = dates[i+1];
                    }
                }
                list.Add(new LongestGap(start, end, gap, kvp.Key));
            }
        }
        list.Sort((x,y) => TimeSpan.Compare(y.gap,x.gap));
        return list;
    }

    public class LongestGap {
        public DateTime start { get; }
        public DateTime end { get; }
        public TimeSpan gap { get; }
        public int doorID { get; }

        public LongestGap(DateTime start, DateTime end, TimeSpan gap, int doorID) {
            this.start = start;
            this.end = end;
            this.gap = gap;
            this.doorID = doorID;
        }

        public override string ToString() {
            return ($"{doorID}: {start}-{end} && {gap}");
        }
    }
}